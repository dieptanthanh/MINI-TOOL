main.c
Chi tiết
Hoạt động
HÔM NAY
T
Bạnđã chỉnh sửa một mục
Drive Notepad • 19:47
C
main.c
THÁNG TRƯỚC
T
Bạnđã tạo một mục trong
27 thg 6
Thư mục Google Drive
Source code
C
main.c
Không có hoạt động nào được ghi lại trước Ngày 27 tháng 06 năm 2016
Đã xóa tất cả lựa chọn 

/**
  ******************************************************************************
  * @file    Project/main.c 
  * @author  MCD Application Team
  * @version V2.2.0
  * @date    30-September-2014
  * @brief   Main program body
   ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */ 

/**********************************************************************************
* Project LIN MINI CONTROL with control Temperature/Humidity and Turn Motor       *
* in INCUBATOR.                                                                   *
* Version 1.0 - - In this Version, using Sensor DHT11 for Humidity and NTC for    *
* temperature. Display on LCD8x2 (module) with 4 button (Set/Sel/Up/Dw) and       *
* 4 LED blink to display status.                                                  *
* This program use only on STM8S005C6. If use on other MCU, please read carefully *
* datasheet of that MCU.                                                          *
* Author: PHAM MINH THUAN                                                         *
* Team: ELECTRONICS DEPART Lin Co., Ltd.                                          *
***********************************************************************************/

/* tao notepad Drive

/* Includes ------------------------------------------------------------------*/
#include "stm8s_conf.h"
#include "stm8s.h"
#include "stm8s_gpio.h"
#include "stm8s_beep.h"
#include "stm8s_itc.h"
#include "stm8s_iwdg.h"
#include "stm8s_tim1.h"
#include "stm8s_it.h"
#include <intrinsics.h>
#include "LCD.h"
#include "math.h"

/* Private defines -----------------------------------------------------------*/
#define Zero_Port  GPIOD
#define Zero_Pin   GPIO_PIN_7

#define SW_Port    GPIOA
#define SW_Set_Pin GPIO_PIN_3
#define SW_Sel_Pin GPIO_PIN_4
#define SW_Up_Pin  GPIO_PIN_5
#define SW_Dw_Pin  GPIO_PIN_6

#define LCD_Port   GPIOB
#define LCD_D4     GPIO_PIN_4
#define LCD_D5     GPIO_PIN_5
#define LCD_D6     GPIO_PIN_6
#define LCD_D7     GPIO_PIN_7
#define LCD_EN     GPIO_PIN_3
#define LCD_RS     GPIO_PIN_1
#define LCD_RW     GPIO_PIN_2

#define Ctr_Port      GPIOC
#define BRLCD_Pin     GPIO_PIN_3
#define Led_Temp_Pin  GPIO_PIN_2
#define Led_Turn_Pin  GPIO_PIN_1
#define Turn_Pin      GPIO_PIN_5
#define Temp_Pin      GPIO_PIN_4

#define LedAct_Port   GPIOE
#define Led_Act_Pin   GPIO_PIN_5

#define DHTxx_Port    GPIOE
#define DHTxx_Pin     GPIO_PIN_6

#define Buzzer_Port   GPIOD
#define Buzzer_Pin    GPIO_PIN_4
//#define F_CPU    CLK_GetClockFreq()
#define DHT_ER 0
#define DHT_OK 1

//#define Delay_us(us) __delay_cycles((F_CPU  *(us)/4000000uL)
//#define WINDOW_VALUE        97
//#define COUNTER_INIT       127
/* Private function prototypes -----------------------------------------------*/
/* Private functions ---------------------------------------------------------*/
static void Clock_Config();
void Tim2_Config();
void Tim3_Config();
void Tim4_Config();
void Tim1_Config();
void Delay_us(uint16_t nus);
void _Delay_us(uint16_t nus);
void Delay_ms(uint16_t nms);
void IWDG_Config();
void GPIO_Config();
void ADC_Config();
void FLASH_Config();
void EXTI_Config();
void DHTxx_SetInput();
void DHTxx_SetOutput();

void control_temp();
void SW_Check();
void Check_Up_Dw();
void Turn_Manual();
unsigned char DHTxx_GetTemHumi();
void Read_TempHumi();
void Read_NTC();
void FLASH_Factory();
//Display Subroutine
void Display_Normal();
void Display_SetTemp();
void Display_SetTurnH();
void Display_SetTurnS();
void Display_Reset();
void Display_ResetOK();
void Display_Alarm();
void Display_OffsetTemp();
void Display_Zero();
///LCD Funtion----------
void LCD_Enable(void);
void LCD_Send4Bit( unsigned char Data );
void LCD_SendCommand (unsigned char command );
void LCD_Init ();
void LCD_Gotoxy(unsigned char x, unsigned char y);
void LCD_Clear();
void LCD_PutChar ( unsigned char Data );
void LCD_Puts (unsigned char *s);
void LCD_Chr(char row,char col,unsigned char _data); //put 1 char at row and col
void LCD_Out(char row,char col,unsigned char *str); //put string at row and col
unsigned short temp=0,temp_set=375,temp_real;
unsigned char humi=0,DHTxx_HUM,DHTxx_TEMP,humi_real=0;
unsigned char sec=0,minu=59,hour=1,sec_turn=35,hour_rom=0,count_turn=0;
unsigned char hour_turn=1,temp_offset=0, temp_al=5;
unsigned short dem=0,count_tim4,sec_tam;
unsigned short count_time_zero;
char EN_ClearLCD=1,en_sensor,en_run=0,en_flash;
char set_stas=0,set_bit=0,sel_bit=0,en_temp=0;
char mode=0,sign=0,en_turn_man=0,en_turn=0;
const unsigned short max=1000;
float value,A,C,T,RT,Vout;
unsigned char check_stas=0,freg=50,freg_er=0,check_freg=0,recheck=0;
uint16_t temp_power=0x00,time_buzzer=0;;
unsigned char time_out=0,en_buzzer=0;
void main()
{
  /* Infinite loop */
  Clock_Config();
  //IWDG_Config();
  disableInterrupts();
  GPIO_Config();
  Tim1_Config();
  Tim3_Config();
  Tim2_Config();
  FLASH_Config();
  EXTI_Config();
  GPIO_WriteHigh(Ctr_Port,Led_Temp_Pin);
  GPIO_WriteHigh(Ctr_Port,Led_Turn_Pin);
  GPIO_WriteHigh(Ctr_Port,Temp_Pin);
  GPIO_WriteHigh(LedAct_Port,Led_Act_Pin);
  GPIO_WriteHigh(Ctr_Port,BRLCD_Pin);
  
  Delay_ms(100);
  LCD_Init();
  Delay_ms(100);
  LCD_Clear();
  Delay_ms(2);
  GPIO_WriteHigh(Buzzer_Port,Buzzer_Pin);
  LCD_Gotoxy(1,1);
  LCD_Puts("LIN-MINI");
  LCD_Gotoxy(2,1);
  LCD_Puts("VER-1.0");
  en_flash=FLASH_ReadByte(0x4000+7);
  if(en_flash==0)
  {
    en_flash=1;
    FLASH_ProgramByte(0x4000+7,1);
    FLASH_Factory();
  }
  temp_set=FLASH_ReadByte(0x4000+0x01)<<8 | FLASH_ReadByte(0x4000);
  if(temp_set>500)
  {
    temp_set=375;
    FLASH_ProgramByte(0x4000,temp_set&0xFF);
    FLASH_ProgramByte(0x4000+1,temp_set>>8);
  }
  hour_turn=FLASH_ReadByte(0x4000+2);
  if(hour_turn>99)
  {
    hour_turn=1;
    FLASH_ProgramByte(0x4000+2,hour_turn);
  }
  if(hour_turn>0)
  {
    hour=hour_turn-1;
    minu=59;
  }
  else
  {
    hour=0; minu=0;
  }
  sec_turn=FLASH_ReadByte(0x4000+3);
  if(sec_turn>99)
  {
    sec_turn=15;
    FLASH_ProgramByte(0x4000+3,sec_turn);
  }
  sign=FLASH_ReadByte(0x4000+4);
  if(sign>1)
  {
    sign=0;
    FLASH_ProgramByte(0x4000+4,sign);
  }
  temp_offset=FLASH_ReadByte(0x4000+5);
  if(temp_offset>50)
  {
    temp_offset=0;
    FLASH_ProgramByte(0x4000+5,temp_offset);
  }
  temp_al=FLASH_ReadByte(0x4000+6);
  if(temp_al>99)
  {
    temp_al=10;
    FLASH_ProgramByte(0x4000+6,temp_al);
  }
  
  Delay_ms(200);
  GPIO_WriteLow(Buzzer_Port,Buzzer_Pin);
  Delay_ms(500);
  GPIO_WriteHigh(Buzzer_Port,Buzzer_Pin);
  
  Delay_ms(200);
  GPIO_WriteLow(Buzzer_Port,Buzzer_Pin);
  Delay_ms(500);
  Delay_ms(500);
  Tim4_Config();
  check_stas=0;
  
  ADC_Config();
  GPIO_WriteHigh(DHTxx_Port,DHTxx_Pin);
  LCD_Clear();
  TIM3_Cmd(ENABLE);
  enableInterrupts();
  while (1)
  {
    /*count_time_zero=temp_power;
    LCD_Chr(1,1,count_time_zero/10000+48);
    LCD_PutChar((count_time_zero%10000)/1000+48);
    LCD_PutChar((count_time_zero%1000)/100+48);
    LCD_PutChar((count_time_zero%100)/10+48);
    LCD_PutChar(count_time_zero%10+48);*/
    //IWDG_ReloadCounter();
    if(freg_er==1&&set_stas<5)
    {
      set_stas=5; EN_ClearLCD=1;temp_power=0;
      GPIO_WriteHigh(Ctr_Port,Led_Temp_Pin);
    }
    if(set_stas==5)
      {
        Display_Zero();
      }
    if(freg_er==0)
    {
      if(set_stas==0)
      {Display_Normal();}
      else if(set_stas==1)
      {
        Check_Up_Dw();
        if(mode==0)
        {
          Display_SetTemp();
        }
        else if(mode==1)
        {
          Display_SetTurnH();
        }
        else if(mode==2)
        {
          Display_SetTurnS();
        }
      }
      else if(set_stas==2)
      {
        //set_bit=0;
        Check_Up_Dw();
        if(mode==0)
        {
          Display_OffsetTemp();
        }
        else if(mode==1)
        {
          Display_Alarm();
        }
      }
      else if(set_stas==3)
      {
        Turn_Manual();
      }
      else if(set_stas==4)
      {
        if(mode==0)
        { Display_Reset();}
        else if(mode==1)
        { Display_ResetOK();}
      }
      SW_Check();
      if(en_temp==1)
      {
        en_temp=0;
        control_temp();
        Read_NTC();
      }
      if(en_sensor==1)
      {
        en_sensor=0;
        Read_TempHumi();
      }
    }
  }
  
}
INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 23)
{
  if(TIM4_GetITStatus(TIM4_IT_UPDATE))
  {
    TIM4_ClearITPendingBit(TIM4_IT_UPDATE);
    count_tim4++;
    if(en_buzzer==1)
    {
      time_buzzer++;
      if(time_buzzer>100 && set_stas!=0)
      { en_buzzer=0; time_buzzer=0;
        GPIO_WriteLow(Buzzer_Port,Buzzer_Pin);
      }
      if(time_buzzer>200 && set_stas==0)
      { en_buzzer=0; time_buzzer=0;
        GPIO_WriteLow(Buzzer_Port,Buzzer_Pin);
      }
    }
    if(count_tim4%100==1) en_temp=1;
    if(count_tim4==250)
    {
      if(temp_real>temp+20 || temp_real+20 <temp) temp=temp_real;
      if((temp_real>(temp_set-3))&&(temp_real<(temp_set+3))) 
      {
        if(temp==temp_set) temp=temp_set;
        else if(temp<temp_set) temp++;
        else if(temp>temp_set) temp--;
        
      }
      else 
      {
         if(temp<temp_real) temp++;
          else if(temp>temp_real) temp--;
          
      }
      
    } 
    if(count_tim4>500)
    {
      count_tim4=0;sec_tam++;
      if(sec_tam>60) sec_tam=0;
      if(freg_er==0 && set_stas!=0) time_out++;
      if(set_stas==0)
      {
        if(sec_tam%2==1) {en_sensor=1;}
        if(temp>=(temp_set+temp_al))
        {
          GPIO_WriteReverse(Buzzer_Port,Buzzer_Pin);
        }
        else if(temp<(temp_set-temp_al))
        {
          if(sec_tam%5==1)
          {
            GPIO_WriteHigh(Buzzer_Port,Buzzer_Pin);
            en_buzzer=1; time_buzzer=0;
          }
        }
        else GPIO_WriteLow(Buzzer_Port,Buzzer_Pin);
      }
      if(time_out>=10)
      {
        time_out=0;
        set_stas=0; EN_ClearLCD=1; mode=0;
      }
      
      
      if(freg_er==0) 
       {
          check_freg++;
          if(check_freg>10)
            {check_freg=0;freg_er=1;
            }
          }
      
      if(en_turn==0&&hour_turn>0) sec++;
      if(set_stas==0)
      {
        GPIO_WriteReverse(LedAct_Port,Led_Act_Pin);
      }
      else if(set_stas==5) GPIO_WriteHigh(LedAct_Port,Led_Act_Pin);
      else GPIO_WriteLow(LedAct_Port,Led_Act_Pin);
      if(en_turn_man==1) {count_turn++;}
      if(sec>=60)
      {
        minu--; sec=0;
        if(minu>60) 
        {
          minu=59;
          hour--;
        }
      }
      if(hour==0 && minu==0 && sec>2&&hour_turn>0)
      {
        en_turn=1;GPIO_WriteHigh(Ctr_Port,Turn_Pin);
        GPIO_WriteLow(Ctr_Port,Led_Turn_Pin);
        hour=hour_turn-1; minu=59; sec=0;
        GPIO_WriteHigh(Buzzer_Port,Buzzer_Pin);
        en_buzzer=1; time_buzzer=0;
      }
      if(en_turn==1)
      {
        count_turn++;
        if(count_turn>=sec_turn)
        {
          GPIO_WriteLow(Ctr_Port,Turn_Pin);
          GPIO_WriteHigh(Ctr_Port,Led_Turn_Pin);
          count_turn=0;
          en_turn=0;
          sec=0;
        }
      }
    }
  }
}

INTERRUPT_HANDLER(TLI_IRQHandler, 0)
{
  if(!GPIO_ReadInputPin(Zero_Port,Zero_Pin))
  {
    if(en_run==0)
    {
      check_stas++;
      count_time_zero=TIM3_GetCounter();
      TIM3_SetCounter(0);
      if(check_stas==10)
      {
        check_stas=0;
        if(count_time_zero<7000 || count_time_zero>11000)
        {  en_run=0;recheck++; if(recheck>100){freg_er=1;recheck=0;}
        }
        else{
        if(count_time_zero>8500 && count_time_zero<10500)
        {
          freg=50;
          set_stas=0; EN_ClearLCD=1;
        }
        else if(count_time_zero>7000 && count_time_zero<8500)
        {
          freg=60;
          set_stas=0; EN_ClearLCD=1;
        }
        en_run=1;
        }
       
      }
    }
    else if(en_run==1)
    {
      TIM3_SetCounter(temp_power);
      check_freg=0;
      
      if(freg_er==1&&set_stas==5)
      {
        set_stas=0; EN_ClearLCD=1;
        freg_er=0;
      }
    }
  
  }   
}
INTERRUPT_HANDLER(TIM3_UPD_OVF_BRK_IRQHandler, 15)
{
    if(TIM3_GetITStatus(TIM3_IT_UPDATE)) 
    {

      TIM3_ClearITPendingBit(TIM3_IT_UPDATE);
      if(en_run==1&&freg_er==0){
      if((freg==50 && temp_power>2800)||(freg==60 && temp_power>4100))
      {
        GPIO_WriteLow(Ctr_Port, Temp_Pin);
        GPIO_WriteLow(Ctr_Port, Led_Temp_Pin);
        Delay_us(5);
        GPIO_WriteHigh(Ctr_Port, Temp_Pin); 
        //GPIO_WriteHigh(Ctr_Port, Led_Temp_Pin);
      }
      else
      {
        GPIO_WriteHigh(Ctr_Port, Temp_Pin);  
        GPIO_WriteHigh(Ctr_Port, Led_Temp_Pin);	
      }
      }
      
    }
}
/* Funtion and Subroutine define ---------------------------------------------*/
 static void Clock_Config()
 {
    CLK_DeInit();
    //CLK_HSECmd(ENABLE);
    CLK_ClockSwitchConfig(CLK_SWITCHMODE_AUTO, CLK_SOURCE_HSE, DISABLE, CLK_CURRENTCLOCKSTATE_DISABLE );
    CLK_HSECmd(ENABLE);
    CLK_ClockSwitchCmd ( ENABLE );
    CLK->SWR  = 0xB4;
    //CLK->SWR  = 0xB4;
   // CLK->SWR=0xB4;
    //CLK_HSIPrescalerConfig(CLK_PRESCALER_HSIDIV1);      //f_Master = HSI/1 = 16MHz
    CLK_SYSCLKConfig(CLK_PRESCALER_CPUDIV1);            //f_CPU = f_Master/1 = 16MHz
    while(CLK_GetFlagStatus(CLK_FLAG_HSERDY)!=SET);     //wait until HSI ready
 }
void Tim2_Config()
{
  //unsigned short Tim2_Prescale=15;
 // unsigned short Tim2_Period=0xFFFF;
  TIM2_DeInit();
  CLK_PeripheralClockConfig(CLK_PERIPHERAL_TIMER2,ENABLE);
  TIM2_TimeBaseInit(TIM2_PRESCALER_16,0xFFFF);
  /* Clear TIM3 update flag */
  TIM2_ClearFlag(TIM2_FLAG_UPDATE);
  /* Enable update interrupt */
  //TIM2_ITConfig(TIM2_IT_UPDATE, DISABLE);
  TIM2_SetCounter(0);
  /* Enable TIM3 */
  TIM2_Cmd(ENABLE);
}
void Tim3_Config()
{
  //unsigned short Tim3_Prescale=15;
  unsigned short Tim3_Period=12000;
  TIM3_DeInit();
  CLK_PeripheralClockConfig(CLK_PERIPHERAL_TIMER3,ENABLE);
  TIM3_TimeBaseInit(TIM3_PRESCALER_16,Tim3_Period);
  /* Clear TIM3 update flag */
  TIM3_ClearFlag(TIM3_FLAG_UPDATE);
  /* Enable update interrupt */
  TIM3_ITConfig(TIM3_IT_UPDATE, ENABLE);
  //TIM3_ARRPreloadConfig(ENABLE);
  /* Enable TIM3 */
  TIM3_Cmd(DISABLE);
}
void Tim4_Config()
{
  //unsigned short Tim4_Prescale=127;
  unsigned short Tim4_Period=255;
  TIM4_DeInit();
  CLK_PeripheralClockConfig(CLK_PERIPHERAL_TIMER4,ENABLE);
  TIM4_TimeBaseInit(TIM4_PRESCALER_128,Tim4_Period);
  /* Clear TIM4 update flag */
  TIM4_ClearFlag(TIM4_FLAG_UPDATE);
  /* Enable update interrupt */
  TIM4_ITConfig(TIM4_IT_UPDATE, ENABLE);
  /* Enable TIM4 */
  TIM4_Cmd(ENABLE);
  disableInterrupts();
}
void Tim1_Config()
{
  //uint16_t Tim1_Prescale=16000;
  //uint16_t Tim1_Period=0xFFFF;
  //TIM1_InternalClockConfig();
  CLK_PeripheralClockConfig(CLK_PERIPHERAL_TIMER1,ENABLE);
  TIM1_DeInit();
  TIM1_TimeBaseInit(15,TIM1_COUNTERMODE_DOWN,0xFFFF,0);
  
  
   /* Clear TIM1 update flag */
  TIM1_ClearFlag(TIM1_FLAG_UPDATE);
  /* Enable update interrupt */
  //TIM1_ITConfig(TIM1_IT_UPDATE, ENABLE);
 
  /* enable interrupts */
  //enableInterrupts();

  /* Enable TIM1 */
  TIM1_Cmd(DISABLE);
}
void EXTI_Config()
{
  EXTI_DeInit();
  EXTI_SetTLISensitivity(EXTI_TLISENSITIVITY_FALL_ONLY );

}
void _Delay_us(uint16_t nus)
{
  TIM1_SetCounter(nus+10);
  TIM1_Cmd(ENABLE);
  while(TIM1_GetCounter()>10) {};
  TIM1_Cmd(DISABLE);
}
void Delay_us(uint16_t nus)
{
  while(nus--)
  {
    nop();
  }
}
void Delay_ms(uint16_t nms)
{
  while(nms-1>0)
  {
    nms--;
    Delay_us(1000-1);
  }
}

void GPIO_Config()
{
  //Set Zero Pin input with Interrupt
  GPIO_Init(Zero_Port,Zero_Pin,GPIO_MODE_IN_PU_IT); 
  //Set SW Input
  GPIO_ExternalPullUpConfig(SW_Port,SW_Set_Pin,ENABLE);
  GPIO_ExternalPullUpConfig(SW_Port,SW_Sel_Pin,ENABLE);
  GPIO_ExternalPullUpConfig(SW_Port,SW_Up_Pin,ENABLE);
  GPIO_ExternalPullUpConfig(SW_Port,SW_Dw_Pin,ENABLE);
  GPIO_Init(SW_Port,SW_Set_Pin,GPIO_MODE_IN_FL_NO_IT);
  GPIO_Init(SW_Port,SW_Sel_Pin,GPIO_MODE_IN_FL_NO_IT);
  GPIO_Init(SW_Port,SW_Up_Pin,GPIO_MODE_IN_FL_NO_IT);
  GPIO_Init(SW_Port,SW_Dw_Pin,GPIO_MODE_IN_FL_NO_IT);
  //Set_LCD
  GPIO_Init(LCD_Port,GPIO_PIN_ALL,GPIO_MODE_OUT_PP_LOW_SLOW);
  //Other
  GPIO_Init(Ctr_Port,Led_Temp_Pin,GPIO_MODE_OUT_PP_LOW_FAST);
  GPIO_Init(Ctr_Port,Led_Turn_Pin,GPIO_MODE_OUT_PP_LOW_FAST);
  GPIO_Init(Ctr_Port,Turn_Pin,GPIO_MODE_OUT_PP_LOW_FAST);
  GPIO_Init(Ctr_Port,Temp_Pin,GPIO_MODE_OUT_PP_LOW_FAST);
  GPIO_Init(Ctr_Port,BRLCD_Pin,GPIO_MODE_OUT_PP_LOW_SLOW);
  GPIO_Init(LedAct_Port,Led_Act_Pin,GPIO_MODE_OUT_PP_LOW_SLOW);
  GPIO_Init(Buzzer_Port,Buzzer_Pin,GPIO_MODE_OUT_PP_LOW_FAST);
  GPIO_Init(DHTxx_Port,DHTxx_Pin,GPIO_MODE_OUT_PP_HIGH_SLOW);
}
void DHTxx_SetInput()
{
  GPIO_Init(DHTxx_Port,DHTxx_Pin,GPIO_MODE_IN_PU_NO_IT);
}
void DHTxx_SetOutput()
{
  GPIO_Init(DHTxx_Port,DHTxx_Pin,GPIO_MODE_OUT_PP_HIGH_SLOW);
}
void GPIO_WriteData_Pin(GPIO_TypeDef *GPIO_Port, GPIO_Pin_TypeDef Pin, unsigned char xdata)
{
  if(xdata==1) GPIO_WriteHigh(GPIO_Port,Pin);
  else if(xdata==0) GPIO_WriteLow(GPIO_Port,Pin);
}
void FLASH_Config()
{
  FLASH_DeInit();
  FLASH_Unlock(FLASH_MEMTYPE_DATA);
  FLASH_SetProgrammingTime(FLASH_PROGRAMTIME_STANDARD);
}
void FLASH_Factory()
{
  temp_set=375;
  hour_turn=1; minu=59;
  sec_turn=15;
  sign=0;
  temp_offset=0;
  temp_al=10;
  FLASH_ProgramByte(0x4000,temp_set&0xFF);
  FLASH_ProgramByte(0x4000+1,temp_set>>8);
  FLASH_ProgramByte(0x4000+2,hour_turn);
  FLASH_ProgramByte(0x4000+3,sec_turn);
  FLASH_ProgramByte(0x4000+4,sign);
  FLASH_ProgramByte(0x4000+5,temp_offset);
  FLASH_ProgramByte(0x4000+6,temp_al);
}
void ADC_Config()
{
  GPIO_Init(GPIOE,GPIO_PIN_7,GPIO_MODE_IN_FL_NO_IT);
  ADC1_DeInit();
  ADC1_Init(ADC1_CONVERSIONMODE_CONTINUOUS,ADC1_CHANNEL_8,ADC1_PRESSEL_FCPU_D2,\
    ADC1_EXTTRIG_TIM,DISABLE,ADC1_ALIGN_RIGHT,ADC1_SCHMITTTRIG_CHANNEL8,DISABLE);
  ADC1_AWDChannelConfig(ADC1_CHANNEL_8,ENABLE);
  CLK_PeripheralClockConfig(CLK_PERIPHERAL_ADC,ENABLE);
  ADC1_DataBufferCmd (ENABLE);
  //ADC1_ITConfig(ADC1_IT_AWS8,DISABLE);
  //ADC1_ScanModeCmd(ENABLE);
  ADC1_StartConversion();
}
unsigned char DHTxx_GetTemHumi()
{
   unsigned char buffer[5]={0,0,0,0,0};
   unsigned char ii,i,checksum;
   unsigned short count;
   GPIO_WriteLow(DHTxx_Port,DHTxx_Pin);
    //Delay_ms(18); // it nhat 18ms
    //count=18100;
    /*while(count--)
    {
      nop();
    }*/
    Delay_ms(20);
    disableInterrupts();
    GPIO_WriteHigh(DHTxx_Port,DHTxx_Pin);
    DHTxx_SetInput();
    //_Delay_us(50);
    TIM2_Cmd(ENABLE);
    TIM2_SetCounter(0);
    while(TIM2_GetCounter()<50){}
    if(GPIO_ReadInputPin(DHTxx_Port,DHTxx_Pin)){
    DHTxx_SetOutput();   // set la cong ra
    GPIO_WriteHigh(DHTxx_Port,DHTxx_Pin);
    enableInterrupts();return DHT_ER ;}
    else
    {
      TIM2_SetCounter(0);
      while(!GPIO_ReadInputPin(DHTxx_Port,DHTxx_Pin))
      {
        if(TIM2_GetCounter()>70){
        DHTxx_SetOutput();    // set la cong ra
        GPIO_WriteHigh(DHTxx_Port,DHTxx_Pin);
        enableInterrupts();return DHT_ER ;}}
      }
           //Doi DaTa len 1
    //delay_us(80);
    
    TIM2_SetCounter(0);
    while(TIM2_GetCounter()<80){}		
    if(!GPIO_ReadInputPin(DHTxx_Port,DHTxx_Pin)){
    DHTxx_SetOutput();    // set la cong ra
    GPIO_WriteHigh(DHTxx_Port,DHTxx_Pin);
    enableInterrupts();return DHT_ER ;}
    else
    {
      TIM2_SetCounter(0);
      while(GPIO_ReadInputPin(DHTxx_Port,DHTxx_Pin))        //Doi Data ve 0
      {
        if(TIM2_GetCounter()>70){
        DHTxx_SetOutput();    // set la cong ra
        GPIO_WriteHigh(DHTxx_Port,DHTxx_Pin);
        enableInterrupts();return DHT_ER ;}
      }
    }
        //Bat dau doc du lieu
    for(i=0;i<5;i++)
    {
      for(ii=0;ii<8;ii++)
      {       //buffer[i]=buffer[i]<<1;
        while(!GPIO_ReadInputPin(DHTxx_Port,DHTxx_Pin));//Doi Data len 1
            //Delay_us(50);
        TIM2_SetCounter(0);
	while(TIM2_GetCounter()<50){}
        if(GPIO_ReadInputPin(DHTxx_Port,DHTxx_Pin))
        {
          buffer[i]|=(1<<(7-ii));
          TIM2_SetCounter(0);
          while(GPIO_ReadInputPin(DHTxx_Port,DHTxx_Pin))//Doi Data xuong 0
          {
            if(TIM2_GetCounter()>80){
            DHTxx_SetOutput();    // set la cong ra
            GPIO_WriteHigh(DHTxx_Port,DHTxx_Pin);
            enableInterrupts();return DHT_ER ;}
          }
        }
      }
    }
    checksum=buffer[0]+buffer[1]+buffer[2]+buffer[3];
    DHTxx_SetOutput();    // set la cong ra
    GPIO_WriteHigh(DHTxx_Port,DHTxx_Pin);
    if((checksum)!=buffer[4]){enableInterrupts();return DHT_ER ;}
           //nhietdo  =   buffer[2];
     DHTxx_HUM =   buffer[0];
    //TIM2_Cmd(DISABLE);    
    enableInterrupts();
    return DHT_OK;
}
void Read_NTC()
{
  char i;
  float temp_buffer=0;
  for (i=0;i<10;i++)
  {
    RT=(ADC1_GetBufferValue(8)*4.7)/(1023 - ADC1_GetBufferValue(8));
    A=logf(RT/10.0);
    C=(A/3470) + 0.003355704698; // 1/(25+273)
    T=(1/C) - 273.15;
    temp_buffer+=(T*10-16.0);
  }
  temp_real=temp_buffer/10;
  if(sign==0)
  {
    temp_real=temp_real+temp_offset;
  }
  else
  {
    temp_real=temp_real-temp_offset;
  }
}
void Read_TempHumi()
{
  if(DHTxx_GetTemHumi()==DHT_OK)
  { humi_real=DHTxx_HUM+20;
    //humi_real=humi_real+20;
  }
  if((humi_real-humi)>10 || humi>(humi_real+10)) {humi=humi_real;}
  else 
  {
    if(humi<humi_real) humi++;
    else if(humi>humi_real) humi--;
  }
   // humi=humi_real;
}
void control_temp()
{
  if(en_run==1)
  {
    if(freg==50)
    {
      if(temp_real<(temp_set-3)) temp_power+=100;
      if(temp_real>(temp_set-3))
      { 
        if(temp_power>7000) temp_power-=800;
        else temp_power+=200;
      }
      if(temp_real>(temp_set)) temp_power-=1000;
                      
      if(temp_power>11800) {temp_power=11800;}
      if(temp_power<2580)  {temp_power=2580;}
    }
    else if(freg==60)
    {
      if(temp_real<(temp_set-3)) temp_power+=100;
      if(temp_real>(temp_set-3))
      { 
        if(temp_power>8000) temp_power-=600;
        else temp_power+=200;
      }
      if(temp_real>(temp_set)) temp_power-=800;
                      
      if(temp_power>=11800) temp_power=11800;
      if(temp_power<=3950)  temp_power=3950;
    }
  }  	
}
void SW_Check()
{
  if(!GPIO_ReadInputPin(SW_Port,SW_Set_Pin))
  {
    //Delay_ms(1);
    if(!GPIO_ReadInputPin(SW_Port,SW_Set_Pin))
    {
      
      time_out=0;
      if(dem==0) {set_bit=1;GPIO_WriteHigh(Buzzer_Port,Buzzer_Pin);
      time_buzzer=0;en_buzzer=1;}
      dem++;
    }
    if(dem>max)
    {
      if(set_stas==0) {set_stas=2;mode=0; EN_ClearLCD=1;set_bit=0;}
      dem=max; 
    }
  }
  else// if(GPIO_ReadInputPin(SW_Port,SW_Set_Pin))
  {
    if(set_bit==1)
    {
      set_bit=0;
      if(freg_er==0){
      if(set_stas==0) {set_stas=1;mode=0;EN_ClearLCD=1;}
      else {set_stas=0;EN_ClearLCD=1; mode=0;}
      }
    }
    else{}
  }
  if(!GPIO_ReadInputPin(SW_Port,SW_Sel_Pin))
  {
    //Delay_ms(1);
    if(!GPIO_ReadInputPin(SW_Port,SW_Sel_Pin))
    {
      time_out=0;
      if(dem==0) {sel_bit=1;GPIO_WriteHigh(Buzzer_Port,Buzzer_Pin);
      time_buzzer=0;en_buzzer=1;}
      dem++;
    }
    if(dem>max)
    {
      if(set_stas==0){set_stas=3;EN_ClearLCD=1;sel_bit=0;}
      dem=max;
    }
  }
  else //if(GPIO_ReadInputPin(SW_Port,SW_Sel_Pin)==1)
  {
    if(sel_bit==1)
    {
      sel_bit=0;
      if(set_stas==1)
      {
        mode++; if(mode>2) mode=0;
        EN_ClearLCD=1;
      }
      else if(set_stas==2)
      {
        mode++;EN_ClearLCD=1;
        if(mode>1) mode=0;
      }
      else if(set_stas==4)
      {
        if(mode==0){ mode =1;EN_ClearLCD=1;FLASH_Factory();}
        //else mode=0;EN_ClearLCD=1;
      }
    }
  }
  if(!GPIO_ReadInputPin(SW_Port,SW_Up_Pin))
  {
    //Delay_ms(1);
    if(!GPIO_ReadInputPin(SW_Port,SW_Up_Pin))
    {
      time_out=0;
      if(set_stas==0){
        dem++;}
      //set_bit=1;
    }
    if(dem>max)
    {
      if(set_stas==0) {EN_ClearLCD=1;mode=0;set_stas=4;}
      //dem=0;
    }
  }
  if(!GPIO_ReadInputPin(SW_Port,SW_Dw_Pin))
  {
    //Delay_ms(1);
    if(!GPIO_ReadInputPin(SW_Port,SW_Dw_Pin))
    {
      time_out=0;
      if(set_stas==0){
        dem++;}
      //set_bit=1;
    }
    if(dem>max)
    {
      if(set_stas==0) {EN_ClearLCD=1;mode=0;set_stas=5;}
      //dem=0;
    }
  }
  if(GPIO_ReadInputPin(SW_Port,SW_Set_Pin)&&GPIO_ReadInputPin(SW_Port,SW_Sel_Pin)
          && GPIO_ReadInputPin(SW_Port,SW_Up_Pin) && GPIO_ReadInputPin(SW_Port,SW_Dw_Pin))
  {
    dem=0;set_bit=0;sel_bit=0;
  }
 
}
void Check_Up_Dw()
{
    if(!GPIO_ReadInputPin(SW_Port,SW_Up_Pin))
    {
      //Delay_ms(1);
      if(!GPIO_ReadInputPin(SW_Port,SW_Up_Pin))
      {
        time_out=0;
        if(dem==0 || dem>500) 
        {
          GPIO_WriteHigh(Buzzer_Port,Buzzer_Pin);
          time_buzzer=0;en_buzzer=1;
          dem=1;
          if(set_stas==1)
          {
            if(mode==0)
            {
              temp_set++;
              if(temp_set>500) temp_set=500;
              FLASH_ProgramByte(0x4000,temp_set&0xFF);
              FLASH_ProgramByte(0x4000+1,temp_set>>8);
            }
            else if(mode==1)
            {
              hour_turn++;
              if(hour_turn>99) hour_turn=99;
              if(hour_turn>0) {hour=hour_turn-1; minu=59; sec=0;}
              else {hour=0; minu=0;}
              FLASH_ProgramByte(0x4000+2,hour_turn);
            }
            else if(mode==2)
            {
              sec_turn++;
              if(sec_turn>99) sec_turn=99;
              FLASH_ProgramByte(0x4000+3,sec_turn);
            }
            else {};
          }
          else if(set_stas==2)
          {
            if(mode==0)
            {
              if(temp_offset==1 && sign==1)
              {temp_offset=0;sign=0;
               FLASH_ProgramByte(0x4000+4,sign);
              }
              else if(sign==1)
              {
                temp_offset--;
                //if(temp_offset>50) temp_offset=50;
              }
              else if(sign==0)
              {
                temp_offset++;
                if(temp_offset>50) temp_offset=50;
              }
              FLASH_ProgramByte(0x4000+5,temp_offset);
            }
            else if(mode==1)
            {
              temp_al++;
              if(temp_al>99) temp_al=99;
              FLASH_ProgramByte(0x4000+6,temp_al);
            }
          }
        }      
        else dem++;
       
      }
    }
    else if(!GPIO_ReadInputPin(SW_Port,SW_Dw_Pin))
    {
      //Delay_ms(1);
      if(!GPIO_ReadInputPin(SW_Port,SW_Dw_Pin))
      {
        time_out=0;
        if(dem==0 || dem>500) 
        {
          GPIO_WriteHigh(Buzzer_Port,Buzzer_Pin);
          time_buzzer=0;en_buzzer=1;
          dem=1;
          if(set_stas==1)
          {
            if(mode==0)
            {
              temp_set--;
              if(temp_set<100) temp_set=100;
              FLASH_ProgramByte(0x4000,temp_set&0xFF);
              FLASH_ProgramByte(0x4000+1,temp_set>>8);
            }
            else if(mode==1)
            {
              hour_turn--;
              if(hour_turn>99) hour_turn=0;
              if(hour_turn>0) {hour=hour_turn-1; minu=59; sec=0;}
              else {hour=0; minu=0;}
              FLASH_ProgramByte(0x4000+2,hour_turn);
            }
            else if(mode==2)
            {
              sec_turn--;
              if(sec_turn>99) sec_turn=0;
              FLASH_ProgramByte(0x4000+3,sec_turn);
            }
            else {};
          }
          else if(set_stas==2)
          {
            if(mode==0)
            {
              if(temp_offset==0)
              {temp_offset=1;sign=1;
               FLASH_ProgramByte(0x4000+4,sign);
              }
              else if(sign==1)
              {
                temp_offset++;
                if(temp_offset>50) temp_offset=50;
                
              }
              else if(sign==0)
              {
                temp_offset--;
              }
              FLASH_ProgramByte(0x4000+5,temp_offset);
            }
            else if(mode==1)
            {
              temp_al--;
              if(temp_al<5) temp_al=5;
              FLASH_ProgramByte(0x4000+6,temp_al);
            }
          }
        }      
        else dem++;
       
      }
    }
    //if(GPIO_ReadInputPin(SW_Port,SW_Up_Pin) && GPIO_ReadInputPin(SW_Port,SW_Dw_Pin))
    //{dem=0;}
}
void Turn_Manual()
{
  if(EN_ClearLCD==1)
  {
    LCD_Clear(); EN_ClearLCD=0;
    LCD_Out(1,1,"Turn Man");
    LCD_Out(2,4,"SEC");
    en_turn_man=1;
  }
  GPIO_WriteHigh(Ctr_Port,Turn_Pin);
  GPIO_WriteLow(Ctr_Port,Led_Turn_Pin);
  LCD_Chr(2,1,count_turn/10+48);
  LCD_PutChar(count_turn%10+48);
  if(GPIO_ReadInputPin(SW_Port,SW_Sel_Pin))
  {
    GPIO_WriteLow(Ctr_Port,Turn_Pin);
    GPIO_WriteHigh(Ctr_Port,Led_Turn_Pin);
    set_stas=0; mode=0; EN_ClearLCD=1;
    en_turn_man=0;count_turn=0;
    if(hour_turn>0)
    {
      hour=hour_turn-1;
      minu=59; sec=0;
    }
  }

}
void Display_Normal()
{
  if(EN_ClearLCD==1)
  {
    LCD_Clear(); EN_ClearLCD=0;
    LCD_Chr(1,6,' ');
    LCD_Chr(2,3,'%');
    //LCD_Chr(2,3,'/');
    LCD_Chr(2,6,' ');
  }
  //Display read temp
  LCD_Chr(1,1,(temp%1000)/100+48);
  LCD_PutChar((temp%100)/10+48);
  LCD_PutChar('.');
  LCD_PutChar(temp%10+48);
  LCD_PutChar(223);
  //Display read humi
  LCD_Chr(2,1,humi/10+48);
  LCD_PutChar(humi%10+48);
  //display sec turn/hh-mm
  
  LCD_Chr(1,7,hour/10+48);
  LCD_PutChar(hour%10+48);
  if(en_turn==0)
  {
    LCD_Chr(2,7,minu/10+48);
    LCD_PutChar(minu%10+48);
  }
  else
  {
    LCD_Chr(2,7,count_turn/10+48);
    LCD_PutChar(count_turn%10+48);
  }
}
void Display_SetTemp()
{
  if(EN_ClearLCD==1)
  {
    LCD_Clear(); EN_ClearLCD=0;
    LCD_Out(1,1,"SET TEMP");
    LCD_Chr(2,5,223);
    LCD_PutChar('C');
  }
  LCD_Chr(2,1,(temp_set%1000)/100+48);
  LCD_PutChar((temp_set%100)/10+48);
  LCD_PutChar('.');
  LCD_PutChar(temp_set%10+48);
}
void Display_SetTurnH()
{
  if(EN_ClearLCD==1)
  {
    LCD_Clear(); EN_ClearLCD=0;
    LCD_Out(1,1,"SET HOUR");
    LCD_Out(2,5,"HOUR");
    
  }
  LCD_Chr(2,1,hour_turn/10+48);
  LCD_PutChar(hour_turn%10+48);
}
void Display_SetTurnS()
{
  if(EN_ClearLCD==1)
  {
    LCD_Clear(); EN_ClearLCD=0;
    LCD_Out(1,1,"SET SEC");
    LCD_Out(2,5,"SEC");
    
  }
  LCD_Chr(2,1,sec_turn/10+48);
  LCD_PutChar(sec_turn%10+48);
}
void Display_Reset()
{
  if(EN_ClearLCD==1)
  {
    LCD_Clear(); EN_ClearLCD=0;
    LCD_Out(1,1,"FACTORY");
    LCD_Out(2,1,"RESET?");
    
  }
}
void Display_ResetOK()
{
  if(EN_ClearLCD==1)
  {
    LCD_Clear(); EN_ClearLCD=0;
    LCD_Out(1,1,"RESET OK");
    LCD_Out(2,1,"EXIT-SET");
  }
}
void Display_OffsetTemp()
{
  if(EN_ClearLCD==1)
  {
    LCD_Clear(); EN_ClearLCD=0;
    LCD_Out(1,1,"-OFFSET-");
    LCD_Chr(2,6,223);
    LCD_PutChar('C');
  }
  if(sign==1) LCD_Chr(2,1,'-');
  else LCD_Chr(2,1,' ');
  LCD_PutChar(temp_offset/10+48);
  LCD_PutChar('.');
  LCD_PutChar(temp_offset%10+48);
}
void Display_Alarm()
{
  if(EN_ClearLCD==1)
  {
    LCD_Clear(); EN_ClearLCD=0;
    LCD_Out(1,1,"TEMPALRM");
    LCD_Out(2,1,"H-L ");
  }
  LCD_Chr(2,5,temp_al/10+48);
  LCD_PutChar('.');
  LCD_PutChar(temp_al%10+48);
  LCD_PutChar(223);
}

void Display_Zero()
{
  if(EN_ClearLCD==1)
  {
    LCD_Clear(); EN_ClearLCD=0;
    LCD_Out(1,1,"SYS FREG");
  }
  if(freg_er==0)
  {
    LCD_Chr(2,1,freg/10+48);
    LCD_PutChar(freg%10+48);
    LCD_Out(2,3,"Hz-OK");
  }
  else
  {
    LCD_Out(2,1,"Error");
  }
}
void LCD_Enable(void)
{
  GPIO_WriteHigh(LCD_Port,LCD_EN);//LCD_EN = 1;
  Delay_us(3);
  GPIO_WriteLow(LCD_Port,LCD_EN);//LCD_EN=0;
  Delay_us(50);
}
void LCD_Send4Bit( unsigned char Data )
{
  GPIO_WriteData_Pin(LCD_Port,LCD_D4,(Data & 0x01));//LCD_D4= Data & 0x01;
  GPIO_WriteData_Pin(LCD_Port,LCD_D5,(Data>>1)&1);//LCD_D5= (Data>>1)&1;
  GPIO_WriteData_Pin(LCD_Port,LCD_D6,(Data>>2)&1);//LCD_D6= (Data>>2)&1; // gui data 4 bit
  GPIO_WriteData_Pin(LCD_Port,LCD_D7,(Data>>3)&1);//LCD_D7= (Data>>3)&1;
}
void LCD_SendCommand (unsigned char command )
{
  LCD_Send4Bit  ( command >>4 );/* Gui 4 bit cao */
  LCD_Enable () ;                                      // gui data 8 bit
  LCD_Send4Bit  ( command  ); /* Gui 4 bit thap*/
  LCD_Enable () ;
}
void LCD_Init ( void )
{
  LCD_Send4Bit(0x00);
  Delay_us(1);
  GPIO_WriteLow(LCD_Port,LCD_RS);//LCD_RS=0;
  LCD_Send4Bit(0x03);
  LCD_Enable();
  Delay_us(50);                         // khai bao LCD che do 4bit 5x7
  LCD_Enable();
  Delay_us(50);
  LCD_Enable();
  LCD_Send4Bit(0x02);
  LCD_Enable();
  Delay_us(50);
  LCD_SendCommand(LCD_DISP_INIT);      // giao thuc 4 bit, hien thi 2 hang, ki tu 5x8
  Delay_us(50);
  LCD_SendCommand(LCD_DISP_ON);     // cho phep hien thi man hinh
  Delay_us(50);
  LCD_SendCommand(LCD_INC_MODE );      // tang ID, khong dich khung hinh
  Delay_us(50);
  LCD_SendCommand(LCD_CLEAR_DISPLAY ); // xoa toan bo khung hinh
  Delay_us(50);
  LCD_SendCommand(LCD_RETRN_HOME);
  Delay_us(50);
}
//////////////////////
void LCD_Gotoxy(unsigned char x, unsigned char y)// x:vi tri con tro( 0-->15), y : vi tri dong ( 0: dong 1,1 dong 2)
{
  unsigned char address;
  if(x==1)
  address = (Line_1+(y-1));
  else if(x==2)  address = (Line_2+(y-1));     // xac dinh vi tri con tro
  else {return;} 
  Delay_us(1);
  LCD_SendCommand(address);
  Delay_us(50);
}
void LCD_Clear()
{
  LCD_SendCommand( LCD_CLEAR_DISPLAY );  // xoa LCD
  Delay_ms(4);
}
void LCD_PutChar ( unsigned char Data )  // LCD_Putchar('x')
{
  GPIO_WriteHigh(LCD_Port,LCD_RS);//LCD_RS=1;
  LCD_SendCommand( Data );  //  xuat data 8 bit 1 ki tu
  GPIO_WriteLow(LCD_Port,LCD_RS);//LCD_RS=0 ;
  Delay_us(10);
}
void LCD_Puts (unsigned char *s)// LCD_Puts("xxx")
{
   while (*s)
   {
      LCD_PutChar(*s);  // xuat chuoi data "xxx"
      s++;
   }
   Delay_us(1);
}
void LCD_Chr(char row,char col,unsigned char _data)
{
  LCD_Gotoxy(row,col);
  LCD_PutChar(_data);
}
void LCD_Out(char row,char col,unsigned char *str)
{
  LCD_Gotoxy(row,col);
  LCD_Puts(str);
}

#ifdef USE_FULL_ASSERT

/**
  * @brief  Reports the name of the source file and the source line number
  *   where the assert_param error has occurred.
  * @param file: pointer to the source file name
  * @param line: assert_param error line source number
  * @retval : None
  */
void assert_failed(u8* file, u32 line)
{ 
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */

  /* Infinite loop */
  while (1)
  {
  }
}
#endif


/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
